# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1duUoP4b3dG1S0AoWXUoSOWkziUeB-apT
"""
#bval = 0

def mainf(m,wi,givenk,g,i1,i2,s1,s2,input_file_path,d1,d2):

    import tifffile as tiff
    # input_file_path = f"'{input_file_path}'"
    print(input_file_path)
    imgo=tiff.imread(input_file_path)
    print(imgo.shape)
    import cv2
    from skimage.feature import graycomatrix
    import math
    import numpy as np
    from matplotlib import pyplot as plt
    from sklearn.metrics import silhouette_score

    import tkinter as tk
    from tkinter import ttk

    root = tk.Tk()
    root.title("Progress Window")
    root.geometry("800x100")
    progress_bar = ttk.Progressbar(root, orient="horizontal", length=450, mode="determinate")
    progress_bar.pack(pady=10)

    def update_progress(progress_label, progress):
        progress_label.config(text="Progress: {:.2f}%".format(progress))
        root.update()
    
    progress_label = tk.Label(root, text="Progress: 0.00%")
    progress_label.pack(padx=10, pady=10)
    
    max=m
    w=[wi]
    g=g
    init1=i1
    init2=i2
    size1=s1
    size2=s2
    img= imgo[init1:init1+size1, init2:init2+size2, :]

    def compute_glcm(img, window_size,g,d1,d2):
        glcm = np.zeros((g,g))
        for i in range(0,img.shape[0] - d1):
            for j in range(img.shape[1] - d2):
                try:
                    p = img[i, j]
                    q = img[i+d1, j+d2]
                    glcm[p,q] += 1
                    glcm[q,p] += 1
                except IndexError:
                    pass
        sum1 = 0
        energy = 0
        homo = 0
        asm = 0
        ent = 0
        idm=0

        for i in range(0, glcm.shape[0]):
            for j in range(0, glcm.shape[1]):
                sum1 = sum1 + ((i-j)*(i-j)*glcm[i,j])
                energy = energy + glcm[i,j]*glcm[i,j]
                homo = homo + (glcm[i,j]/(1+abs(i-j)))
                #asm = asm + glcm[i,j]*glcm[i,j]
                idm = idm + glcm[i, j]/(1+(i-j)*(i-j))
                ent = ent + glcm[i,j]*math.log(1/(0.01 + glcm[i,j]))
        
    

    # return features_glcm

    #     for i in range(0, glcm.shape[0]):
    #         for j in range(0, glcm.shape[1]):
    #             sum1 = sum1 + ((i-j)*(i-j)*glcm[i,j])
    #             energy = energy + glcm[i,j]*glcm[i,j]
    #             homo = homo + (glcm[i,j]/(1+abs(i-j)))
    #             asm = asm + glcm[i,j]*glcm[i,j]
    #             #ent = ent + glcm[i,j]*(math.log(1/glcm[i,j]))
    #             ent=1
 

        return sum1, ent, homo, asm, idm
        
        
        
        
 

    def compute_glcm_features(img, pca_idx, window_sizes,g,d1,d2):
        # Compute the GLCM features for PCA1
        img_pca = img
        features = []
        
        for w in window_sizes:
            s=img_pca.shape[0] - w
            window_half = w // 2
            for i in range(window_half, img_pca.shape[0] - window_half):
                for j in range(window_half, img_pca.shape[1] - window_half):
                    img_window = img_pca[i-window_half:i+window_half+1, j-window_half:j+window_half+1]
                    sum1, energy, homo, asm, ent = compute_glcm(img_window, w,g,d1,d2)
                    print(sum1)
                    feature=np.array([sum1, energy, homo, asm, ent])
                    print(i,j,feature)
                    update_progress(progress_label, (((i/(img_pca.shape[1] - window_half))*100)+(j/(img_pca.shape[1] - window_half))))
                    progress_bar["value"] = (i/(img_pca.shape[1] - window_half))*100
                    #bval=bval+ (300/(s*s))
                    features.append(feature)
        features = np.stack(features, axis=1)
        root.destroy()
        return features

    def normalize_array(arr,g):
        min_val = np.min(arr)
        max_val = np.max(arr)
        

        arr_norm = (arr - min_val) / (max_val - min_val)
        
        arr_scaled = (arr_norm * (g-1)).astype(np.uint8)
        
        return arr_scaled

    def showimg(imgi,name):
        cv2.imwrite(name,imgi)

    print(img.shape)
    img = img.reshape((img.shape[0]*img.shape[1], img.shape[2]))


    mean = np.mean(img, axis=0)
    img_centered = img - mean

    covariance_matrix = np.cov(img_centered.T)


    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)

    sorted_indices = np.argsort(eigenvalues)[::-1]
    sorted_eigenvectors = eigenvectors[:, sorted_indices]



    principal_components = np.dot(img_centered, sorted_eigenvectors)


    pca1 = principal_components[:, 0]
    pca1try=pca1.reshape((size1, size2))
    showimg(pca1try,'PCA1_without_normalizing.jpeg')
    pca1 = normalize_array(pca1.reshape((size1, size2)),g)
    showimg(pca1,'PCA1.jpeg')





    #pca2 = principal_components[:, 1]
    #pca2 = pca2.reshape((863, 876))

    #print(pca1)
    wg=wi
    matrix=compute_glcm_features(pca1, 0, [wg],g,d1,d2)

    print(matrix.shape)

    #matrix= np.loadtxt('text.txt')
    print(matrix)
    nmatrix = np.squeeze(matrix)
    print(nmatrix)
    np.savetxt('text.txt',matrix)
    #matrix= np.loadtxt('text.txt')

    from sklearn.cluster import KMeans
    import numpy as np

    X=nmatrix[0:4, :].T
    print(X.shape)
    xn=X[:, 0:4]
    print(xn.shape)

    k_range = range(2, 10)
    silhouette_scores = []
    for k in k_range:
        kmeans = KMeans(n_clusters=k)
        labels = kmeans.fit_predict(X)
        score = silhouette_score(X, labels)
        silhouette_scores.append(score)
    optimal_k = k_range[np.argmax(silhouette_scores)]
    
    
    kmeans = KMeans(n_clusters=optimal_k, random_state=0)
    kmeans.fit(X)

    
    
    
    
    cluster_labels = kmeans.labels_

    # Reshape the cluster assignments back to a 2D array
    cluster_labels_2d = np.reshape(cluster_labels, (pca1.shape[0]-wg+1,pca1.shape[1]-wg+1))

    # Define your own cluster labels based on the K-means cluster assignments
    my_cluster_labels = np.zeros_like(cluster_labels)


    for i in range (0,optimal_k):
        my_cluster_labels[cluster_labels == i] = (max/k)*i

    output= np.reshape(my_cluster_labels, (pca1.shape[0]-wg+1,pca1.shape[1]-wg+1))
    showimg(output,'output.jpeg')



    kmeans2 = KMeans(n_clusters=givenk, random_state=0)
    kmeans2.fit(X)
    
    
    cluster_labels2 = kmeans2.labels_

    # Reshape the cluster assignments back to a 2D array
    cluster_labels_2d2 = np.reshape(cluster_labels2, (pca1.shape[0]-wg+1,pca1.shape[1]-wg+1))

    # Define your own cluster labels based on the K-means cluster assignments
    my_cluster_labels2 = np.zeros_like(cluster_labels2)
    for i in range (0,givenk):
        my_cluster_labels2[cluster_labels2 == i] = (max/k)*i

    output2= np.reshape(my_cluster_labels2, (pca1.shape[0]-wg+1,pca1.shape[1]-wg+1))
    showimg(output2,'output2.jpeg')




    return optimal_k
    

    
    

#mainf(1000,3,4,1000,0,0,10,10)